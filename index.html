<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cờ CARO ONLINE — Demo (Notepad++)</title>
  <style>
    :root{--bg:#0f172a;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8;--good:#16a34a;--bad:#ef4444}
    *{box-sizing:border-box;font-family:Inter, system-ui, Arial}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071126,var(--bg));color:#e6eef6}
    .wrap{max-width:1100px;margin:24px auto;padding:20px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:18px;border-radius:12px;box-shadow:0 6px 30px rgba(2,6,23,0.6)}
    header{display:flex;align-items:center;gap:12px}
    header h1{margin:0;font-size:20px}

    /* Layout */
    .screen{display:none}
    .screen.active{display:block}

    /* Login */
    .login-center{display:flex;gap:20px;align-items:center}
    .btn{background:var(--accent);border:none;padding:10px 14px;border-radius:8px;color:#022;cursor:pointer;font-weight:600}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}

    /* Lobby */
    .lobby-grid{display:grid;grid-template-columns:1fr 360px;gap:14px;margin-top:14px}
    .room-list{height:520px;overflow:auto;padding:10px;border-radius:8px;border:1px dashed rgba(255,255,255,0.03)}
    .room{display:flex;justify-content:space-between;padding:8px;border-radius:6px;margin-bottom:8px;background:rgba(255,255,255,0.01)}

    .controls{display:flex;gap:8px;margin-bottom:8px}
    input[type=text]{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}

    /* Leaderboard */
    .leader{margin-top:8px;padding:8px;border-radius:8px;background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01))}
    .leader div{display:flex;justify-content:space-between}

    /* Game */
    .board-wrap{display:flex;gap:18px;align-items:flex-start}
    .board{display:grid;grid-template-columns:repeat(24,28px);grid-template-rows:repeat(24,28px);gap:1px;padding:6px;background:#0b1220;border-radius:8px}
    .cell{width:28px;height:28px;background:#071423;display:flex;align-items:center;justify-content:center;border-radius:4px;position:relative;cursor:pointer}
    .cell.lock{background:#02111a;cursor:not-allowed;opacity:0.6}
    .cell.highlight{outline:2px solid rgba(6,182,212,0.7)}
    .cell.last{box-shadow:0 0 0 2px rgba(99,102,241,0.45) inset}
    .stone{width:20px;height:20px;border-radius:50%}
    .stone.x{background:#f8fafc}
    .stone.o{background:#111827}

    .side{width:320px}
    .meta{display:flex;justify-content:space-between;align-items:center}
    .timer{font-size:28px;font-weight:700}

    footer{margin-top:16px;color:var(--muted);font-size:13px}

    /* small */
    @media(max-width:1000px){.lobby-grid{grid-template-columns:1fr}} 
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <img src="" alt="logo" style="width:44px;height:44px;border-radius:8px;background:linear-gradient(90deg,#06b6d4,#7c3aed)">
        <h1>Cờ CARO ONLINE (Demo) - Notepad++</h1>
      </header>

      <!-- Screens: login, lobby, game -->
      <div id="login" class="screen active card" style="margin-top:12px">
        <h2>Đăng nhập</h2>
        <p>Đăng nhập bằng Google (yêu cầu Client ID &amp; HTTPS). Nếu không có, dùng đăng nhập tạm bằng tên.</p>
        <div style="display:flex;gap:12px;align-items:center;margin-top:8px">
          <!-- Google button placeholder. Replace CLIENT_ID in the script to enable Google Identity Services -->
          <div id="g_id_onload" style="display:none"></div>
          <button id="fakeGoogle" class="btn">Đăng nhập bằng Google (demo)</button>
          <button id="guest" class="btn ghost">Đăng nhập bằng tên</button>
        </div>
        <div style="margin-top:12px">
          <label>Tên (mặc định lấy từ gmail nếu dùng Google)</label><br>
          <input id="manualName" type="text" placeholder="Nhập tên..." />
        </div>
      </div>

      <div id="lobby" class="screen card" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <strong id="playerName">-</strong>
            <div style="font-size:13px;color:var(--muted)">Điểm hạng: <span id="rankPoints">-</span></div>
          </div>
          <div>
            <button id="btnFindRandom" class="btn">Tìm Ngẫu Nhiên</button>
            <button id="btnCreateRoom" class="btn ghost">Tạo Phòng</button>
            <button id="btnFindRoom" class="btn ghost">Tìm Phòng</button>
            <button id="btnRename" class="btn ghost">Đổi Tên</button>
          </div>
        </div>

        <div class="lobby-grid">
          <div>
            <div class="controls">
              <input id="roomCodeInput" type="text" placeholder="Mã phòng (5 chữ số)" />
              <button id="joinByCode" class="btn">Vào</button>
            </div>
            <div style="font-size:13px;color:var(--muted)">Danh sách phòng có 1 người (tự động cập nhật):</div>
            <div id="rooms" class="room-list"></div>
          </div>

          <div class="side">
            <div class="card" style="padding:10px">
              <div style="display:flex;justify-content:space-between;align-items:center">
                <strong>Bảng xếp hạng (Top 10)</strong>
                <button id="refreshBoard" class="btn ghost">Tải</button>
              </div>
              <div id="leaderboard" class="leader"></div>
            </div>
            <div style="margin-top:10px" class="card">
              <div style="font-size:13px;color:var(--muted)">Mẹo:</div>
              <ul style="margin:6px 0 0 18px;color:var(--muted)">
                <li>Bàn cờ 24x24, ô giữa là ô lock không được đánh.</li>
                <li>Con cờ đầu tiên phải đánh ở ô liền kề ô lock.</li>
                <li>Người chơi được +1 / -1 điểm hạng khi thắng/thua. Reset về 10 mỗi ngày.</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <div id="game" class="screen card" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <button id="backToLobby" class="btn ghost">← Trở về sảnh</button>
          </div>
          <div class="meta">
            <div><strong id="roomLabel">Phòng: -</strong><div style="font-size:12px;color:var(--muted)" id="playerRole"></div></div>
            <div class="timer" id="turnTimer">--</div>
          </div>
        </div>
        <div style="margin-top:12px;display:flex;gap:12px">
          <div class="board-wrap">
            <div id="board" class="board"></div>
            <div style="display:flex;flex-direction:column;gap:10px;margin-left:10px">
              <div style="background:rgba(255,255,255,0.02);padding:8px;border-radius:8px">Lượt: <span id="turnInfo">-</span></div>
              <div style="background:rgba(255,255,255,0.02);padding:8px;border-radius:8px">Trạng thái: <span id="status">Chưa bắt đầu</span></div>
            </div>
          </div>
        </div>
      </div>

      <footer>Ghi chú: Đây là bản demo chạy hoàn toàn trên trình duyệt (localStorage). Để chơi mạng thật cần server hoặc WebRTC. File hoạt động offline (ngoại trừ Google Sign-In yêu cầu HTTPS).</footer>
    </div>
  </div>

  <script>
  /* --------- Utilities & Data Layer (localStorage based demo) --------- */
  const STORAGE = {
    USERS: 'caro_users_v1',
    ROOMS: 'caro_rooms_v1'
  }

  function loadJSON(key, def){try{return JSON.parse(localStorage.getItem(key))||def}catch(e){return def}}
  function saveJSON(key,val){localStorage.setItem(key, JSON.stringify(val))}

  // users: {emailOrId: {name, points, lastReset: 'YYYY-MM-DD'}}
  const db = {
    users: loadJSON(STORAGE.USERS, {}),
    rooms: loadJSON(STORAGE.ROOMS, {})
  }

  function todayStr(){const d=new Date();return d.getFullYear()+"-"+(d.getMonth()+1)+"-"+d.getDate()}

  function ensureUser(id, name){
    if(!db.users[id]){
      db.users[id] = {name:name||id, points:10, lastReset: todayStr()}
      saveJSON(STORAGE.USERS, db.users)
    } else {
      // reset daily
      if(db.users[id].lastReset !== todayStr()){
        db.users[id].points = 10
        db.users[id].lastReset = todayStr()
        saveJSON(STORAGE.USERS, db.users)
      }
    }
  }

  function updateLeaderboard(){
    const arr = Object.entries(db.users).map(([k,v])=>({id:k,name:v.name,points:v.points}));
    arr.sort((a,b)=>b.points-a.points);
    const top = arr.slice(0,10);
    const el = document.getElementById('leaderboard'); el.innerHTML='';
    top.forEach((p,i)=>{
      const div = document.createElement('div'); div.style.padding='6px 0'; div.innerHTML = `<div style="display:flex;justify-content:space-between"><div>${i+1}. ${escapeHtml(p.name)}</div><div>${p.points}</div></div>`;
      el.appendChild(div);
    })
  }

  function escapeHtml(s){return (s||'').toString().replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[c])}

  // rooms: {code: {players: [id], board: [], status:'waiting'|'playing'|'finished', turn:'x'|'o', lastMove:{r,c}, createdAt:ms}}
  function saveRooms(){ saveJSON(STORAGE.ROOMS, db.rooms) }

  function genCode(){return String(Math.floor(10000 + Math.random()*90000))}

  // Sync with other tabs (very simple) - listen to storage events
  window.addEventListener('storage', (e)=>{ if(e.key===STORAGE.ROOMS || e.key===STORAGE.USERS){ db.rooms = loadJSON(STORAGE.ROOMS, {}); db.users = loadJSON(STORAGE.USERS, {}); renderRooms(); updateLeaderboard(); renderLobbyPlayer(); } })

  /* --------- Sounds via WebAudio (click and ticking) --------- */
  const AUD= new (window.AudioContext||window.webkitAudioContext)();
  function clickSound(){const o=AUD.createOscillator(),g=AUD.createGain(); o.type='square'; o.frequency.value=800; g.gain.value=0.02; o.connect(g); g.connect(AUD.destination); o.start(); o.stop(AUD.currentTime+0.04)}
  function tickSound(){const o=AUD.createOscillator(),g=AUD.createGain(); o.type='sine'; o.frequency.value=1200; g.gain.value=0.01; o.connect(g); g.connect(AUD.destination); o.start(); o.stop(AUD.currentTime+0.08)}

  /* --------- UI logic --------- */
  let currentUserId = null
  let currentRoom = null
  let currentRole = null // 'x' or 'o'
  let turnTimerInterval = null
  let turnRemaining = 60

  function showScreen(id){document.querySelectorAll('.screen').forEach(s=>s.classList.remove('active'));document.getElementById(id).classList.add('active')}

  // Login controls
  document.getElementById('fakeGoogle').addEventListener('click', ()=>{
    const fakeEmail = 'user'+Math.floor(Math.random()*999)+'@demo.local'
    const name = 'user'+Math.floor(Math.random()*999)
    loginSuccess(fakeEmail,name)
  })
  document.getElementById('guest').addEventListener('click', ()=>{
    const name = (document.getElementById('manualName').value || 'Khách')
    const id = 'guest_'+name+Math.floor(Math.random()*9999)
    loginSuccess(id,name)
  })

  function loginSuccess(id, name){ currentUserId = id; ensureUser(id,name); db.users[id].name = name; saveJSON(STORAGE.USERS, db.users); renderLobby(); showScreen('lobby'); }

  function renderLobby(){ renderLobbyPlayer(); renderRooms(); updateLeaderboard(); }
  function renderLobbyPlayer(){ document.getElementById('playerName').textContent = (db.users[currentUserId] && db.users[currentUserId].name) || '-' ; document.getElementById('rankPoints').textContent = (db.users[currentUserId] && db.users[currentUserId].points) || '-' }

  // Rooms list
  function renderRooms(){ const container = document.getElementById('rooms'); container.innerHTML='';
    for(const [code,room] of Object.entries(db.rooms)){
      if(room.players.length===1 && room.status==='waiting'){
        const div=document.createElement('div'); div.className='room'; div.innerHTML = `<div>${code} — ${escapeHtml(room.players[0].name||room.players[0])}</div><div><button class='btn joinRoom' data-code='${code}'>Vào</button></div>`
        container.appendChild(div)
      }
    }
    document.querySelectorAll('.joinRoom').forEach(b=>b.addEventListener('click', e=>{ joinRoom(b.dataset.code) }))
  }

  // Create room
  document.getElementById('btnCreateRoom').addEventListener('click', ()=>{
    const code = genCode();
    db.rooms[code] = {players:[{id:currentUserId,name:db.users[currentUserId].name}], board: Array(24*24).fill(null), status:'waiting', turn:'x', lastMove:null, createdAt:Date.now()}
    saveRooms(); renderRooms(); // go directly to room (waiting)
    enterRoom(code);
  })

  document.getElementById('joinByCode').addEventListener('click', ()=>{ const code = document.getElementById('roomCodeInput').value.trim(); if(code) joinRoom(code) })

  function joinRoom(code){ const room = db.rooms[code]; if(!room){alert('Không tìm thấy phòng');return}
    if(room.players.find(p=>p.id===currentUserId)){ enterRoom(code); return }
    if(room.players.length>=2){alert('Phòng đã đủ người'); return }
    room.players.push({id:currentUserId,name:db.users[currentUserId].name}); room.status='playing'; // start game
    // init board
    room.board = Array(24*24).fill(null);
    room.turn = 'x'; room.lastMove=null; saveRooms(); enterRoom(code);
  }

  function enterRoom(code){ currentRoom = code; const room = db.rooms[code]; // determine role
    const idx = room.players.findIndex(p=>p.id===currentUserId)
    currentRole = idx===0 ? 'x' : 'o'
    document.getElementById('roomLabel').textContent = 'Phòng: '+code
    document.getElementById('playerRole').textContent = 'Bạn: '+currentRole.toUpperCase()
    showScreen('game'); renderBoard(); startSyncRoom()
  }

  document.getElementById('btnFindRandom').addEventListener('click', ()=>{
    // find any waiting room
    for(const [code,room] of Object.entries(db.rooms)){
      if(room.players.length===1 && room.status==='waiting'){ joinRoom(code); return }
    }
    // else create one
    document.getElementById('btnCreateRoom').click()
  })

  document.getElementById('btnRename').addEventListener('click', ()=>{
    const newName = prompt('Nhập tên mới', db.users[currentUserId].name)
    if(newName){ db.users[currentUserId].name = newName; saveJSON(STORAGE.USERS, db.users); renderLobbyPlayer(); updateLeaderboard(); }
  })

  document.getElementById('backToLobby').addEventListener('click', ()=>{ leaveRoom(); showScreen('lobby'); })

  function leaveRoom(){ if(!currentRoom) return; const room = db.rooms[currentRoom]; if(!room) return; room.players = room.players.filter(p=>p.id!==currentUserId); if(room.players.length===0) delete db.rooms[currentRoom]; else room.status='waiting'; saveRooms(); currentRoom=null; currentRole=null; renderRooms(); }

  // Game rendering
  function renderBoard(){ const room = db.rooms[currentRoom]; const boardEl = document.getElementById('board'); boardEl.innerHTML='';
    const N=24; const lockR=Math.floor(N/2), lockC=Math.floor(N/2);
    for(let r=0;r<N;r++) for(let c=0;c<N;c++){
      const idx = r*N + c; const cell = document.createElement('div'); cell.className='cell'; cell.dataset.r=r; cell.dataset.c=c;
      if(r===lockR && c===lockC){ cell.classList.add('lock'); }
      const val = room.board[idx]; if(val){ const s=document.createElement('div'); s.className='stone '+(val==='x'?'x':'o'); cell.appendChild(s); }
      // highlight adjacent to lock when empty
      if(!room.board.some(x=>x!==null)){
        if(Math.abs(r-lockR)<=1 && Math.abs(c-lockC)<=1 && !(r===lockR && c===lockC)) cell.classList.add('highlight')
      }
      // last move
      if(room.lastMove && room.lastMove.r===r && room.lastMove.c===c) cell.classList.add('last')

      cell.addEventListener('click', ()=>onCellClick(r,c))
      boardEl.appendChild(cell)
    }
    document.getElementById('turnInfo').textContent = room.turn.toUpperCase()
    document.getElementById('status').textContent = room.status
  }

  function onCellClick(r,c){ const room = db.rooms[currentRoom]; if(!room) return; if(room.status!=='playing'){alert('Trò chơi chưa bắt đầu');return}
    const N=24; const idx=r*N+c; if(room.board[idx]) return; const lockR=Math.floor(N/2), lockC=Math.floor(N/2);
    if(r===lockR && c===lockC) return; // lock cannot be played
    // if first move overall must be adjacent to lock
    if(!room.board.some(x=>x!==null)){
      if(Math.abs(r-lockR)>1 || Math.abs(c-lockC)>1){ alert('Lượt đầu phải đánh gần ô lock'); return }
    }
    // check if it's this player's turn
    const role = currentRole;
    if(room.turn !== role){ alert('Chưa đến lượt bạn'); return }
    // make move
    room.board[idx] = role
    room.lastMove = {r,c}
    // switch turn
    room.turn = (room.turn==='x'?'o':'x')
    saveRooms(); clickSound(); renderBoard(); checkWinOrDraw(); resetTurnTimerRemote();
  }

  // Very simple win check (5 in a row) around last move
  function checkWinOrDraw(){ const room = db.rooms[currentRoom]; const N=24; const lm = room.lastMove; if(!lm) return; const dirs=[[1,0],[0,1],[1,1],[1,-1]]; const me = room.board[lm.r*N+lm.c];
    for(const d of dirs){ let cnt=1; for(let s=1;s<24;s++){const rr=lm.r+d[0]*s, cc=lm.c+d[1]*s; if(rr<0||rr>=N||cc<0||cc>=N)break; if(room.board[rr*N+cc]===me)cnt++;else break}
      for(let s=1;s<24;s++){const rr=lm.r-d[0]*s, cc=lm.c-d[1]*s; if(rr<0||rr>=N||cc<0||cc>=N)break; if(room.board[rr*N+cc]===me)cnt++;else break}
      if(cnt>=5){ room.status='finished'; saveRooms(); renderBoard(); onGameEnd(me); return }
    }
    // draw check
    if(room.board.every(x=>x!==null)){ room.status='finished'; saveRooms(); renderBoard(); onGameEnd(null); }
  }

  function onGameEnd(winner){ const room = db.rooms[currentRoom]; if(!room) return; let msg='Hòa!';
    if(winner){ msg = (winner==='x' ? (room.players[0] && room.players[0].name) : (room.players[1] && room.players[1].name)) + ' thắng!';
      // update points: find which user won
      // simple: assign +1 to winner id, -1 to loser id
      const winnerId = (winner==='x' ? room.players[0] && room.players[0].id : room.players[1] && room.players[1].id)
      const loserId = (winner==='x' ? room.players[1] && room.players[1].id : room.players[0] && room.players[0].id)
      if(winnerId && db.users[winnerId]) db.users[winnerId].points = (db.users[winnerId].points||0) + 1
      if(loserId && db.users[loserId]) db.users[loserId].points = (db.users[loserId].points||0) - 1
      saveJSON(STORAGE.USERS, db.users)
    }
    alert(msg)
    updateLeaderboard();
  }

  /* --------- Turn timer (per-room) using room object lastTick and remaining (very simple) --------- */
  function startSyncRoom(){ stopTurnTimer(); renderBoard(); // start polling for room updates
    if(!currentRoom) return; if(turnTimerInterval) clearInterval(turnTimerInterval);
    turnTimerInterval = setInterval(()=>{
      db.rooms = loadJSON(STORAGE.ROOMS, {}); // refresh
      if(!(currentRoom in db.rooms)){ // room deleted
        alert('Phòng đã đóng'); stopTurnTimer(); showScreen('lobby'); return
      }
      // refresh UI
      renderBoard(); renderLobbyPlayer(); updateLeaderboard();
      // handle turn timer
      const room = db.rooms[currentRoom]; if(room.status==='playing'){
        if(!room._turnMeta) room._turnMeta = {startedAt: Date.now(), remaining:60}
        // If lastMove changed, reset timer
        if(room._lastMoveTs !== (room.lastMove ? JSON.stringify(room.lastMove) : null)){
          room._lastMoveTs = (room.lastMove ? JSON.stringify(room.lastMove) : null)
          room._turnMeta.startedAt = Date.now(); room._turnMeta.remaining = 60; saveRooms();
        }
        // compute remaining using stored meta
        const elapsed = Math.floor((Date.now() - room._turnMeta.startedAt)/1000)
        const remain = Math.max(0, 60 - elapsed)
        document.getElementById('turnTimer').textContent = remain + 's'
        if(remain<=10 && remain>0) tickSound()
        if(remain===0){ // current player loses (the one who should play)
          // determine who lost by time: player whose role equals room.turn
          const loserRole = room.turn; const loserId = loserRole==='x' ? (room.players[0] && room.players[0].id) : (room.players[1] && room.players[1].id)
          const winnerId = loserRole==='x' ? (room.players[1] && room.players[1].id) : (room.players[0] && room.players[0].id)
          if(loserId && db.users[loserId]) db.users[loserId].points = (db.users[loserId].points||0) - 1
          if(winnerId && db.users[winnerId]) db.users[winnerId].points = (db.users[winnerId].points||0) + 1
          room.status='finished'; saveRooms(); saveJSON(STORAGE.USERS, db.users); updateLeaderboard(); alert('Hết giờ! Người chơi ' + loserRole.toUpperCase() + ' thua')
        }
      } else {
        document.getElementById('turnTimer').textContent = '--'
      }
    }, 800)
  }
  function stopTurnTimer(){ if(turnTimerInterval) clearInterval(turnTimerInterval); turnTimerInterval=null }

  function resetTurnTimerRemote(){ // update room meta so all tabs reset timer
    const room = db.rooms[currentRoom]; if(!room) return; if(!room._turnMeta) room._turnMeta = {};
    room._turnMeta.startedAt = Date.now(); saveRooms();
  }

  // initial UI state
  showScreen('login')

  // periodic lobby sync
  setInterval(()=>{ db.rooms = loadJSON(STORAGE.ROOMS, {}); db.users = loadJSON(STORAGE.USERS, {}); renderRooms(); updateLeaderboard(); }, 1500)

  // expose some helpers for debugging
  window._caro = {db, saveRooms}

  </script>
</body>
</html>
